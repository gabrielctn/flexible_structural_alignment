"""
.. module:: pdb
   :synopsis: This module implements functions for PDB files manipulation.
"""

# Third-party modules
import sys
from Bio.PDB.PDBIO import PDBIO
from Bio.PDB import Dice
from Bio.PDB import Select


def write_pu_pdb(structure, chain_id, start, end, filename):
    """
    This function writes down a selected portion of a PDB, like a PU !

    Args:
        structure (PDB Structure): The PDB structure generated by the PDBparser.
        chain_id (str): The chain ID of the portion to save.
        start (int): The starting residue index.
        end (int): The ending residue index.
        filename (str): the name of the file to save.
    """
    Dice.extract(structure, chain_id, start, end, filename)


def remove_aligned_pu_from_pdb(structure_in, pdb_out, start, end):
    """
    This function writes a new PDB file based on the "structure_in" one, without the residues
    between start and end.
    In other terms, it extracts the residues of the PU (between start-end indexes) from the native
    structure (the PDB on which the PU was just aligned on).

    Args:
        structure_in (PDBParser Structure): The structure of the native PDB.
        pdb_out (str): Filename of the cropped PDB.
        start (int): Start residue index of the PU (included)
        end (int): End residue index of the PU (included)
    """
    class ResSelect(Select):
        def accept_residue(self, res):
            return False if res.id[1] >= start and res.id[1] <= end else True
    io = PDBIO()
    io.set_structure(structure_in)
    io.save(pdb_out, ResSelect())


def reindex_pdb_by_index(start_index=1, pdb_txt=''):
    """
    reindex residue number of PDB format text

    options:
        start_index - index of first residue
        pdb_txt     - text of input PDB to be reindexed
    """
    pdb_txt_reindex = ''
    current_old_index = ''  # residue number in origin PDB
    warn_chain_id = ''  # warning about new chain ID

    for line in pdb_txt.splitlines():
        if len(line) < 27 or (not line.startswith("ATOM  ")
                              and not line.startswith("HETATM") and not line.startswith("TER")):
            pdb_txt_reindex += line+'\n'
            continue
        elif not line[16] in ['A', ' ']:  # alternative location identifier
            continue
        res_seq = line[22:27]  # residue sequence number
        current_chain_id = line[21]  # chain identifier

        if not current_old_index:  # first residue encountered
            current_old_index = res_seq  # residue number in origin PDB
            current_new_index = int(start_index)
            chain_id = current_chain_id
            res_seq_new = str(current_new_index)
            res_seq_new = ' '*(4-len(res_seq_new))+res_seq_new+' '
        elif current_chain_id != chain_id:
            if warn_chain_id != current_chain_id:
                sys.stderr.write(
                    "Warning! Discarding chain '%s'\n" % current_chain_id)
                warn_chain_id = current_chain_id
            continue
        elif res_seq != current_old_index:
            current_new_index += 1
            current_old_index = res_seq
            res_seq_new = str(current_new_index)
            res_seq_new = ' '*(4-len(res_seq_new))+res_seq_new+' '
        pdb_txt_reindex += line[:16]+' '+line[17:22]+res_seq_new+line[27:]+'\n'
    return pdb_txt_reindex


def reindex_pdb(start_index, infile, clean=True):
    """parse PDB file "infile", reindex it according to start index or
    sequence file "start_index", and return the text of renumbered PDB
    """
    f_in = open(infile, 'rU')
    pdb_txt = ''
    for line in f_in.read().splitlines():
        if line.startswith("END"):
            if clean:
                line = line.replace("ENDMDL", "END   ")
            pdb_txt += line+'\n'
            break
        if (line.startswith("ATOM  ") or line.startswith("TER")\
            or (not clean and not line[:6]\
                in ["DBREF ", "SEQADV", "MODRES", "HELIX ", "SHEET ", "SSBOND", "SITE  "])):
            pdb_txt += line+'\n'
    f_in.close()

    pdb_txt_reindex = reindex_pdb_by_index(start_index, pdb_txt)
    return pdb_txt_reindex
