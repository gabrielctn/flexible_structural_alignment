"""
.. module:: Parse
   :synopsis: This module implements parsing functions.
"""

# Third-party modules
import sys
import re
from Bio.PDB import Dice


def parse_tm_align(tm_align_res):
    """
    This function parses TMalign's terminal output.
    It retrieves:
    1. TMscore for chain 1 (normalized by the length of chain 1)
    2. TMscore for chain 2 (normalized by the length of chain 2)
    3. RMSD
    4. Alignment length

    Args:
        tm_align_res (list): Terminal's output of TMalign

    Returns:
        Tuple: (tm_score1, tm_score2, rmsd, aligned_length)
    """
    tm_score_regex = re.compile("^TM-score= (\\d+\\.\\d+).*$")
    rmsd_regex = re.compile("^.*RMSD=\\s+(\\d+\\.\\d+).*$")
    aligned_len_regex = re.compile("^Aligned length=\\s*(\\d+).*$")

    tm_score1 = None
    tm_score2 = None
    rmsd = None
    aligned_len = None

    flag = False
    for line in tm_align_res:
        tm_score_found = re.search(tm_score_regex, line)
        rmsd_found = re.search(rmsd_regex, line)
        aligned_len_found = re.search(aligned_len_regex, line)
        if tm_score_found:
            if flag:  # Get 2nd TM-score
                tm_score2 = float(tm_score_found.group(1))
            else:     # Get 1st TM-score
                tm_score1 = float(tm_score_found.group(1))
                flag = True
        if rmsd_found:
            rmsd = float(rmsd_found.group(1))
        if aligned_len_found:
            aligned_len = int(aligned_len_found.group(1))
    return (tm_score1, tm_score2, rmsd, aligned_len)


def parse_protein_peeling(peeling_res):
    """
    This function parses the output of Protein Peeling software.

    Args:
        peeling_res (str): Terminal's output of Protein Peeling 3 software.

    Returns:
        dictionary: Number of
    """
    peeling_dict = {"NB_PU": [], "PU_BOUNDS": []}
    res_line_regex = re.compile("^[^#].*$")
    for line in peeling_res:
        # Looking for lines not starting with "#"
        res_line_found = re.search(res_line_regex, line)
        if res_line_found:
            res_line = res_line_found.group(0).split()
            peeling_dict["NB_PU"].append(int(res_line[4]))
            pu_bounds = [(x, y) for x, y in zip(res_line[5::2], res_line[6::2])]
            peeling_dict["PU_BOUNDS"].append(pu_bounds)
    return peeling_dict


def write_pdb_portion(structure, chain_id, start, end, filename):
    """
    This function writes down a selected portion of a PDB.

    Args:
        structure (PDB Structure): The PDB structure generated by the PDBparser.
        chain_id (str): The chain ID of the portion to save.
        start (int): The starting residue index.
        end (int): The ending residue index.
        filename (str): the name of the file to save.
    """
    Dice.extract(structure, chain_id, start, end, filename)


def reindex_pdb_by_index(start_index=1, pdb_txt=''):
    '''
    reindex residue number of PDB format text

    options:
        start_index - index of first residue
        pdb_txt     - text of input PDB to be reindexed
    '''
    pdb_txt_reindex = ''
    current_old_index = ''  # residue number in origin PDB
    warn_chain_id = ''  # warning about new chain ID

    for line in pdb_txt.splitlines():
        if len(line) < 27 or (not line.startswith("ATOM  ")
                              and not line.startswith("HETATM") and not line.startswith("TER")):
            pdb_txt_reindex += line+'\n'
            continue
        elif not line[16] in ['A', ' ']:  # alternative location identifier
            continue
        res_seq = line[22:27]  # residue sequence number
        current_chain_id = line[21]  # chain identifier

        if not current_old_index:  # first residue encountered
            current_old_index = res_seq  # residue number in origin PDB
            current_new_index = int(start_index)
            chain_id = current_chain_id
            res_seq_new = str(current_new_index)
            res_seq_new = ' '*(4-len(res_seq_new))+res_seq_new+' '
        elif current_chain_id != chain_id:
            if warn_chain_id != current_chain_id:
                sys.stderr.write(
                    "Warning! Discarding chain '%s'\n" % current_chain_id)
                warn_chain_id = current_chain_id
            continue
        elif res_seq != current_old_index:
            current_new_index += 1
            current_old_index = res_seq
            res_seq_new = str(current_new_index)
            res_seq_new = ' '*(4-len(res_seq_new))+res_seq_new+' '
        pdb_txt_reindex += line[:16]+' '+line[17:22]+res_seq_new+line[27:]+'\n'
    return pdb_txt_reindex


def reindex_pdb(start_index, infile, clean=True):
    '''parse PDB file "infile", reindex it according to start index or
    sequence file "start_index", and return the text of renumbered PDB
    '''
    f_in = open(infile, 'rU')
    pdb_txt = ''
    for line in f_in.read().splitlines():
        if line.startswith("END"):
            if clean:
                line = line.replace("ENDMDL", "END   ")
            pdb_txt += line+'\n'
            break
        if (line.startswith("ATOM  ") or line.startswith("TER")\
            or (not clean and not line[:6]\
                in ["DBREF ", "SEQADV", "MODRES", "HELIX ", "SHEET ", "SSBOND", "SITE  "])):
            pdb_txt += line+'\n'
    f_in.close()

    pdb_txt_reindex = reindex_pdb_by_index(start_index, pdb_txt)
    return pdb_txt_reindex
