"""
.. module:: Parse
   :synopsis: This module implements parsing functions.
"""

# Third-party modules
import re
from Bio.PDB import Dice


def parse_tm_align(tm_align_res):
    """
    This function parses TMalign's terminal output.
    It retrieves:
    1. TMscore for chain 1 (normalized by the length of chain 1)
    2. TMscore for chain 2 (normalized by the length of chain 2)
    3. RMSD
    4. Alignment length

    Args:
        tm_align_res (list): Terminal's output of TMalign

    Returns:
        Tuple: (tm_score1, tm_score2, rmsd, aligned_length)
    """
    tm_score_regex = re.compile("^TM-score= (\\d+\\.\\d+).*$")
    rmsd_regex = re.compile("^.*RMSD=\\s+(\\d+\\.\\d+).*$")
    aligned_len_regex = re.compile("^Aligned length=\\s*(\\d+).*$")

    tm_score1 = None
    tm_score2 = None
    rmsd = None
    aligned_len = None

    flag = False
    for line in tm_align_res:
        tm_score_found = re.search(tm_score_regex, line)
        rmsd_found = re.search(rmsd_regex, line)
        aligned_len_found = re.search(aligned_len_regex, line)
        if tm_score_found:
            if flag:  # Get 2nd TM-score
                tm_score2 = float(tm_score_found.group(1))
            else:     # Get 1st TM-score
                tm_score1 = float(tm_score_found.group(1))
                flag = True
        if rmsd_found:
            rmsd = float(rmsd_found.group(1))
        if aligned_len_found:
            aligned_len = int(aligned_len_found.group(1))
    return (tm_score1, tm_score2, rmsd, aligned_len)


def parse_protein_peeling(peeling_res):
    """
    This function parses the output of Protein Peeling software.

    Args:
        peeling_res (str): Terminal's output of Protein Peeling 3 software.

    Returns:
        dictionary: Number of
    """
    peeling_dict = {"NB_PU": [], "PU_bounds": []}
    res_line_regex = re.compile("^[^#].*$")
    for line in peeling_res:
        # Looking for lines not starting with "#"
        res_line_found = re.search(res_line_regex, line)
        if res_line_found:
            res_line = res_line_found.group(0).split()
            peeling_dict["NB_PU"].append(int(res_line[4]))
            peeling_dict["PU_bounds"].append([(x, y) for x, y in zip(res_line[5::2], res_line[6::2])])
    return peeling_dict


def write_pdb_portion(structure, chain_id, start, end, filename):
    """
    This function writes down a selected portion of a PDB.

    Args:
        structure (PDB Structure): The PDB structure generated by the PDBparser.
        chain_id (str): The chain ID of the portion to save.
        start (int): The starting residue index.
        end (int): The ending residue index.
        filename (str): the name of the file to save.
    """
    Dice.extract(structure, chain_id, start, end, filename)


def reindex_pdb_by_index(startindex=1, PDBtxt=''):
    '''
    reindex residue number of PDB format text

    options:
        startindex - index of first residue
        PDBtxt     - text of input PDB to be reindexed
    '''
    PDBtxt_reindex = ''
    current_old_index = ''  # residue number in origin PDB
    warn_chainID = ''  # warning about new chain ID

    for line in PDBtxt.splitlines():
        if len(line) < 27 or (not line.startswith("ATOM  ")
                              and not line.startswith("HETATM") and not line.startswith("TER")):
            PDBtxt_reindex += line+'\n'
            continue
        elif not line[16] in ['A', ' ']:  # alternative location identifier
            continue
        resSeq = line[22:27]  # residue sequence number
        current_chainID = line[21]  # chain identifier

        if not current_old_index:  # first residue encountered
            current_old_index = resSeq  # residue number in origin PDB
            current_new_index = int(startindex)
            chainID = current_chainID
            resSeq_new = str(current_new_index)
            resSeq_new = ' '*(4-len(resSeq_new))+resSeq_new+' '
        elif current_chainID != chainID:
            if warn_chainID != current_chainID:
                sys.stderr.write(
                    "Warning! Discarding chain '%s'\n" % current_chainID)
                warn_chainID = current_chainID
            continue
        elif resSeq != current_old_index:
            current_new_index += 1
            current_old_index = resSeq
            resSeq_new = str(current_new_index)
            resSeq_new = ' '*(4-len(resSeq_new))+resSeq_new+' '
        PDBtxt_reindex += line[:16]+' '+line[17:22]+resSeq_new+line[27:]+'\n'
    return PDBtxt_reindex


def reindex_pdb(startindex, infile, clean=True):
    '''parse PDB file "infile", reindex it according to start index or
    sequence file "startindex", and return the text of renumbered PDB
    '''
    fp = open(infile, 'rU')
    PDBtxt = ''
    for line in fp.read().splitlines():
        if line.startswith("END"):
            if clean:
                line = line.replace("ENDMDL", "END   ")
            PDBtxt += line+'\n'
            break
        if line.startswith("ATOM  ") or line.startswith("TER") or (
            clean == False and not line[:6] in ["DBREF ", "SEQADV", "MODRES",
                                                "HELIX ", "SHEET ", "SSBOND", "SITE  "]):
            PDBtxt += line+'\n'
    fp.close()

    PDBtxt_reindex = reindex_pdb_by_index(startindex, PDBtxt)
    return PDBtxt_reindex
