#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""
    Usage:
        ./flex PDB_FILE_1 PDB_FILE_2

    Arguments:
        PDB_FILE_1         Path to the first PDB file to align
        PDB_FILE_2         Path to the second PDB file to align

    Options:
        -h, --help        Show this
"""


# Third-party modules
import subprocess
import os
import re
from datetime import datetime
from Bio.PDB.PDBParser import PDBParser
from docopt import docopt
from schema import Schema, Use, SchemaError

# Local modules
import src.parse as parse


def check_args():
    """
        Checks and validates the types of inputs parsed by docopt from command line.
    """
    schema = Schema({
        'PDB_FILE_1': Use(open, error='PDB_FILE_1 should be readable'),
        'PDB_FILE_2': Use(open, error='PDB_FILE_2 should be readable')
        })
    try:
        schema.validate(ARGUMENTS)
    except SchemaError as err:
        exit(err)


def clean_peeling_outputs():
    """
    Removes unused files generated by Protein Peeling program.
    """
    pattern = "^file_.*$"
    for file in os.listdir("."):
        if re.search(pattern, file):
            os.remove(os.path.join(".", file))


if __name__ == "__main__":

    START_TIME = datetime.now()

    ### Parse command line
    ######################
    ARGUMENTS = docopt(__doc__, version='Protein Flexible Alignment Tool 1.0')
    # Check the types and ranges of the command line arguments parsed by docopt
    check_args()

    ### Definition of filenames and paths
    ##################
    PDB_FILE_1 = ARGUMENTS["PDB_FILE_1"]
    PDB_FILE_2 = ARGUMENTS["PDB_FILE_2"]
    PDB_NAME_1 = os.path.splitext(os.path.basename(PDB_FILE_1))[0]
    PDB_NAME_2 = os.path.splitext(os.path.basename(PDB_FILE_2))[0]
    DSSP_FILE_1 = "./data/" + PDB_NAME_1 + ".dss"
    DSSP_FILE_2 = "./data/" + PDB_NAME_2 + ".dss"

    ### Launch TMalign
    ##################
    TM_ALIGN_RES = subprocess.Popen(["./bin/TMalign", PDB_FILE_1, PDB_FILE_2],
                                    stdout=subprocess.PIPE).communicate()[0]\
                                    .decode("UTF-8").split("\n")

    ### Parse TMalign
    #################
    TM_SCORE1, TM_SCORE2, RMSD, ALIGNED_LEN = parse.parse_tm_align(TM_ALIGN_RES)

    ### Parse PDB
    #############
    # The PDB file is reindexed to fit the Protein Peeling program
    REINDEXED_PDB = parse.reindex_pdb(1, PDB_FILE_1, True)
    # Write the new reindexed PDB
    NEW_PDB_NAME_1 = PDB_NAME_1 + "_new.pdb"
    NEW_PDB_FILE_1 = "data/" + NEW_PDB_NAME_1
    with open(NEW_PDB_FILE_1, "w") as f_out:
        f_out.write(REINDEXED_PDB)
    STRUCTURE = PDBParser(QUIET=True).get_structure(NEW_PDB_NAME_1, NEW_PDB_FILE_1)

    ### Launch DSSP
    ###############
    OUT, ERR = subprocess.Popen(["./bin/mkdssp", "-i", NEW_PDB_FILE_1, "-o", DSSP_FILE_1],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()

    ### Launch Peeling
    ##################
    PEELING_PROCESS_RES = subprocess.Popen(["./bin/peeling11_4.1", "-pdb", NEW_PDB_FILE_1,
                                            "-dssp", DSSP_FILE_1, "-R2", "98", "-ss2", "8",
                                            "-lspu", "20", "-mspu", "0", "-d0", "6.0",
                                            "-delta", "1.5", "-oss", "1", "-p", "0", "-cp", "0",
                                            "-npu", "16"], stdout=subprocess.PIPE).communicate()[0]
    PEELING_RES = PEELING_PROCESS_RES.decode("UTF-8").split("\n")
    clean_peeling_outputs()
    for i in PEELING_RES:
        print(i)

    ### Parse Peeling
    #################
    PEELING_DICT = parse.parse_protein_peeling(PEELING_RES)

    # Write all PU in different PDB files
    for peeling_level, all_pu in enumerate(PEELING_DICT["PU_BOUNDS"]):
        for pu_index, (start, end) in enumerate(all_pu):
            # File name = PDB_NAME_1 + peeling_level + "pu" + PU_index + ".pdb"
            pu_pdb = "results/"+PDB_NAME_1+"_"+str(peeling_level+1)+"_pu_"+str(pu_index+1)+".pdb"
            parse.write_pdb_portion(STRUCTURE, "A", int(start), int(end), pu_pdb)

    print("\nTotal runtime: {} seconds".format(str(datetime.now() - START_TIME)))
